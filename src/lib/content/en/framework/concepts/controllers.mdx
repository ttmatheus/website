---
title: Controllers
description: Learn about the controller pattern in AzuraJS
category: Main Concepts
icon: lucide:target
order: 1
---

# Controllers üéØ

Controllers serve as the architectural core of AzuraJS applications. They utilize the Model-View-Controller (MVC) pattern to organize API endpoints into logical, maintainable, and type-safe classes using TypeScript decorators.

<Callout type="info" title="Separation of Concerns">
  Controllers promote clean architecture by separating routing logic from
  business logic. This organization reduces code duplication and improves
  maintainability.
</Callout>

## What is a Controller? üìö

A controller is a TypeScript class decorated with `@Controller`. It groups related route handlers. Each method within the class represents a specific endpoint and is decorated with HTTP method decorators such as `@Get`, `@Post`, `@Put`, or `@Delete`.

```typescript
import { Controller, Get, Post } from "azurajs/decorators";

@Controller("/api/products")
export class ProductController {
  @Get()
  list() {
    return { products: [] };
  }

  @Post()
  create() {
    return { message: "Product created" };
  }
}
```

## Controller Decorator üè∑Ô∏è

The `@Controller(prefix?)` decorator defines the base route for all methods within the class.

- **Basic Usage**: `@Controller("/users")` prepends `/users` to all nested routes.
- **No Prefix**: `@Controller()` means routes will be defined solely by their method decorators.
- **Nested Paths**: `@Controller("/api/v1/admin")` allows for deep path nesting.

## Parameter Injection üíâ

AzuraJS provides a suite of decorators to inject request data directly into your controller methods.

| Decorator        | Description                                     |
| :--------------- | :---------------------------------------------- |
| `@Req()`         | Injects the full `RequestServer` object.        |
| `@Res()`         | Injects the full `ResponseServer` object.       |
| `@Body()`        | Injects the parsed request body.                |
| `@Param(name)`   | Injects a specific URL parameter (e.g., `:id`). |
| `@Query(name)`   | Injects a specific query string parameter.      |
| `@Headers(name)` | Injects a specific header value.                |
| `@Cookies(name)` | Injects a specific cookie value.                |
| `@Ip()`          | Injects the client's IP address.                |

## Best Practices ‚ú®

1.  **Single Responsibility**: Dedicate each controller to a single resource or domain (e.g., `UserController`, `OrderController`).
2.  **Service Layer**: Delegate complex business logic to service classes; keep controllers focused on HTTP handling.
3.  **Consistent Responses**: Adhere to a standardized JSON response structure across your API.
4.  **Error Handling**: Leverage the `HttpError` class for consistent error reporting with appropriate status codes.

## Next Steps üìñ

- [üõ£Ô∏è **Routing**](/docs/en/framework/concepts/routing): Learn about route patterns and parameters.
- [üè∑Ô∏è **Decorators**](/docs/en/framework/concepts/decorators): Master all available decorators.
- [üõ°Ô∏è **Validation**](/docs/en/framework/features/validation): Validate request data automatically.
