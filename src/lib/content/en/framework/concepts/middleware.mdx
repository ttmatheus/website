---
title: Middleware
description: Intercept and modify requests and responses in AzuraJS
category: Main Concepts
icon: lucide:plug
order: 4
---

# Middleware ğŸ”Œ

Middleware functions are a fundamental part of the request-response cycle in AzuraJS. They have access to the `RequestServer`, `ResponseServer`, and the `next` function, allowing them to execute code, transform data, or terminate the request before it reaches the route handler.

## How Middleware Works

A middleware function typically performs one of the following tasks:

- Executes arbitrary code.
- Modifies the request or response objects.
- Ends the request-response cycle (e.g., sending a response early).
- Calls `next()` to pass control to the next middleware in the stack.

Each middleware receives three arguments:

1.  `req`: The request object (`RequestServer`).
2.  `res`: The response object (`ResponseServer`).
3.  `next`: The callback to continue execution.

```typescript
import type { RequestServer, ResponseServer } from "azurajs/types";

const loggerMiddleware = (
  req: RequestServer,
  res: ResponseServer,
  next: () => Promise<void>,
) => {
  console.log(`Request received: ${req.method} ${req.url}`);
  next();
};
```

## Registering Middleware

Middleware can be applied at different scopes: globally, per controller, or per route.

### Global Middleware

To apply middleware to every request, register it using the `app.use()` method.

```typescript
import { AzuraClient } from "azurajs";

const app = new AzuraClient();

app.use(loggerMiddleware);
app.use(anotherMiddleware);
```

### Controller Middleware

Use the `@UseMiddleware` decorator to apply middleware to all routes within a controller.

```typescript
import { Controller, Get, UseMiddleware } from "azurajs/decorators";
import type { RequestServer, ResponseServer } from "azurajs/types";

const authMiddleware = (
  req: RequestServer,
  res: ResponseServer,
  next: () => Promise<void>,
) => {
  if (!req.headers.authorization) {
    return res.status(401).send("Unauthorized");
  }
  next();
};

@UseMiddleware(authMiddleware)
@Controller("/admin")
export class AdminController {
  @Get("/dashboard")
  getDashboard() {
    return "Admin Panel";
  }
}
```

### Route Middleware

The `@UseMiddleware` decorator can also target individual methods to apply middleware selectively.

```typescript
import { Controller, Get, UseMiddleware } from "azurajs/decorators";

const logTimeMiddleware = (
  req: RequestServer,
  res: ResponseServer,
  next: () => Promise<void>,
) => {
  const start = Date.now();
  res.on("finish", () => {
    console.log(`Request ${req.url} took ${Date.now() - start}ms`);
  });
  next();
};

@Controller("/data")
export class DataController {
  @UseMiddleware(logTimeMiddleware)
  @Get("/heavy-report")
  getHeavyReport() {
    return "Heavy Report";
  }
}
```

## Asynchronous Middleware

Middleware functions fully support `async/await`. Always await `next()` if you need to perform actions after the subsequent middleware completes, or if consistency is required in the execution order.

```typescript
const asyncMiddleware = async (req, res, next) => {
  await someAsyncOperation();
  await next();
};
```

## Next Steps ğŸ“–

- [âš™ï¸ **Configuration**](/docs/en/framework/getting-started/configuration): See how to configure global middlewares via `azura.config.ts`.
- [ğŸš¨ **Error Handling**](/docs/en/framework/features/error-handling): Understand how error middlewares can be used to centralize exception handling.
