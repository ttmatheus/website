---
title: Error Handling
description: Robust and centralized error management in AzuraJS
category: Features
icon: lucide:bug
order: 8
---

# Error Handling ðŸš¨

Effective error handling is critical for API reliability and security. AzuraJS provides a structured mechanism to manage exceptions centrally, ensuring consistent responses and preventing sensitive data leakage.

## HttpError

The `HttpError` class is the standard utility for throwing exceptions with specific HTTP status codes. It integrates seamlessly with the framework's error management pipeline.

```typescript
import { HttpError } from "azurajs/errors";
import { Controller, Get, Param, Res } from "azurajs/decorators";
import type { ResponseServer } from "azurajs/types";

@Controller("/users")
export class UserController {
  @Get("/:id")
  getUser(@Param("id") id: string, @Res() res: ResponseServer) {
    if (id === "invalid") {
      throw new HttpError(400, "Invalid user ID");
    }
    if (id === "notfound") {
      throw new HttpError(404, "User not found", { code: "USER_NOT_FOUND" });
    }
    return { id, name: `User ${id}` };
  }
}
```

### `HttpError` Constructor

The constructor accepts a status code, a message, and optional payload data.

```typescript
new HttpError(status: number, message?: string, payload?: any)
```

- `status`: HTTP status code (e.g., 400, 404, 500).
- `message`: Human-readable error description. Defaults to the standard HTTP message if omitted.
- `payload`: Optional object containing metadata or structured error details.

## Global Error Middleware

AzuraJS intercepts unhandled exceptions via a default error middleware. You can override this to facilitate custom logging or response formatting.

A custom error middleware must accept four arguments: `(err, req, res, next)`.

```typescript
import { AzuraClient } from "azurajs";
import { HttpError } from "azurajs/errors";
import type { RequestServer, ResponseServer } from "azurajs/types";

const app = new AzuraClient();

app.use(
  (err: Error, req: RequestServer, res: ResponseServer, next: Function) => {
    if (err instanceof HttpError) {
      return res.status(err.status).json({
        statusCode: err.status,
        message: err.message,
        error: err.payload || null,
      });
    } else {
      console.error(err);
      return res.status(500).json({
        statusCode: 500,
        message: "Internal server error",
        error: process.env.NODE_ENV === "development" ? err.message : "",
      });
    }
  },
);
```

## Async Error Handling

AzuraJS automatically captures promise rejections within async controller methods and middleware. Explicit `try/catch` blocks are only necessary when you need to handle specific errors locally before they propagate to the global handler.

## Next Steps ðŸ“–

- [ðŸ“Š **Logger**](/docs/en/framework/features/logger): Use the logger to register errors effectively.
- [âš¡ **Cluster Mode**](/docs/en/framework/features/cluster-mode): Understand how error handling works in a multi-process environment.
