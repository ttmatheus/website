---
title: Plugins
description: Complete guide to AzuraJS plugins - extend your application with powerful built-in features
category: Features
icon: lucide:plug
order: 10
---

# Plugins ðŸ”Œ

AzuraJS includes a comprehensive ecosystem of **17 built-in plugins**, providing robust functionality without external dependencies. These plugins are accessible via the `azurajs/plugins` export and adhere to a consistent, intuitive API.

## Overview

Plugins in AzuraJS are middleware functions applicable globally or to specific routes. They are designed to be:

- **Zero Dependencies**: Constructed entirely with Node.js native modules.
- **Type-Safe**: Complete TypeScript support with detailed definitions.
- **Composable**: Easily combinable for complex functionality.
- **Performant**: Optimized for production environments.
- **Extensible**: Straightforward custom plugin creation.

## Available Plugins

### Security Plugins

#### ðŸ›¡ï¸ Helmet

Implements security headers to safeguard against common vulnerabilities.

```typescript
import { AzuraClient } from "azurajs";
import { helmet } from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  frameguard: { action: 'deny' },
  noSniff: true,
  xssFilter: true,
  hidePoweredBy: true
}));
```

**Options:**
- `contentSecurityPolicy`: various CSP directives.
- `hsts`: HTTP Strict Transport Security settings.
- `frameguard`: X-Frame-Options configuration.
- `noSniff`: Enables X-Content-Type-Options: nosniff.
- `xssFilter`: Enables X-XSS-Protection.
- `hidePoweredBy`: Removes the X-Powered-By header.
- `dnsPrefetchControl`: Controls DNS prefetching.
- `referrerPolicy`: Sets the Referrer-Policy.

#### ðŸŒ CORS

Enables Cross-Origin Resource Sharing.

```typescript
import { cors } from "azurajs/plugins";

app.use(cors({
  origins: ["http://localhost:3000", "https://example.com"],
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
  allowedHeaders: ["Content-Type", "Authorization"],
  exposedHeaders: ["X-Total-Count"],
  credentials: true,
  maxAge: 3600
}));
```

**Options:**
- `origins`: Array of allowed origins (`["*"]` for all).
- `methods`: Allowed HTTP methods.
- `allowedHeaders`: Permitted request headers.
- `exposedHeaders`: Headers exposed to the browser.
- `credentials`: Supports cookies and authorization headers.
- `maxAge`: Preflight cache duration in seconds.

#### ðŸ”’ CSRF

Protects against Cross-Site Request Forgery attacks.

```typescript
import { csrf } from "azurajs/plugins";

app.use(csrf({
  secret: process.env.CSRF_SECRET,
  cookie: {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  },
  ignoreMethods: ['GET', 'HEAD', 'OPTIONS']
}));

// Usage in routes
app.get('/form', (req, res) => {
  res.send(`
    <form method="POST" action="/submit">
      <input type="hidden" name="_csrf" value="${req.csrfToken()}">
      <button>Submit</button>
    </form>
  `);
});
```

**Features:**
- Automatic token generation.
- Cookie-based or session-based storage.
- Configurable ignored methods.
- Token validation.

#### ðŸ” JWT Authentication

A complete JWT system including signing, verification, and middleware.

```typescript
import { jwtMiddleware, createJWT, verifyJWT } from "azurajs/plugins";

// Token Creation
const token = createJWT(
  { userId: 123, role: 'admin' },
  { 
    secret: process.env.JWT_SECRET,
    expiresIn: 3600,
    algorithm: 'HS256',
    issuer: 'myapp',
    audience: 'myapp-users'
  }
);

// Route Protection
app.use('/api/protected', jwtMiddleware({
  secret: process.env.JWT_SECRET,
  credentialsRequired: true,
  algorithm: 'HS256',
  getToken: (req) => {
    const auth = req.headers.authorization;
    if (auth && auth.startsWith('Bearer ')) {
      return auth.substring(7);
    }
    return null;
  }
}));

// Accessing Payload
app.get('/api/protected/profile', (req, res) => {
  const user = req.user;
  res.json({ user });
});

// Manual Verification
try {
  const payload = verifyJWT(token, { 
    secret: process.env.JWT_SECRET 
  });
  console.log(payload);
} catch (error) {
  console.error('Invalid token:', error.message);
}
```

**Features:**
- Supports HS256, HS384, and HS512 algorithms.
- Standard JWT claims (exp, iat, nbf, iss, aud).
- Custom token extraction.
- Type-safe payload access.

### Performance Plugins

#### ðŸ—œï¸ Compression

Automatically compresses responses using gzip, deflate, or Brotli.

```typescript
import { compression } from "azurajs/plugins";

app.use(compression({
  threshold: 1024,
  level: 6,
  filter: (contentType) => {
    return /json|text|javascript|css|xml|svg/.test(contentType);
  }
}));
```

**Options:**
- `threshold`: Minimum response size in bytes.
- `level`: Compression level (0-9).
- `filter`: Content type filter function.

**Benefits:**
- Up to 70% bandwidth reduction.
- Automatic encoding negotiation.
- Smart content-type filtering.

#### ðŸ·ï¸ ETag

Enables HTTP caching via ETag generation and validation.

```typescript
import { etag } from "azurajs/plugins";

app.use(etag({
  algorithm: 'sha1',
  weak: true
}));
```

**Features:**
- Automatic generation.
- Returns 304 Not Modified when appropriate.
- Supports strong and weak ETags.

#### ðŸ—‚ï¸ Static Files

Serves static files with caching and security headers.

```typescript
import { serveStatic } from "azurajs/plugins";

app.use('/public', serveStatic('./public', {
  maxAge: 86400000,
  index: 'index.html',
  dotfiles: 'ignore',
  etag: true,
  lastModified: true,
  extensions: ['html', 'htm']
}));
```

**Options:**
- `maxAge`: Cache duration in ms.
- `index`: Default index file.
- `dotfiles`: Handling strategy ('allow', 'ignore', 'deny').
- `etag`: Toggle ETag generation.
- `lastModified`: Toggle Last-Modified header.
- `extensions`: File extensions to try.

### Data Handling Plugins

#### ðŸ“¦ Session

Manages user sessions via memory or custom stores.

```typescript
import { session } from "azurajs/plugins";

app.use(session({
  secret: process.env.SESSION_SECRET,
  name: 'sessionId',
  cookie: {
    maxAge: 86400000,
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  },
  rolling: true,
  resave: false,
  saveUninitialized: false
}));

app.post('/login', (req, res) => {
  req.session.userId = user.id;
  req.session.role = user.role;
  res.json({ success: true });
});

app.get('/profile', (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  res.json({ 
    userId: req.session.userId,
    role: req.session.role 
  });
});

app.post('/logout', (req, res) => {
  req.session.destroy();
  res.json({ success: true });
});
```

**Custom Store Example:**

```typescript
class RedisStore {
  constructor(private redis: RedisClient) {}

  async get(id: string) {
    const data = await this.redis.get(`session:${id}`);
    return data ? JSON.parse(data) : null;
  }

  async set(id: string, data: any) {
    await this.redis.setex(`session:${id}`, 86400, JSON.stringify(data));
  }

  async destroy(id: string) {
    await this.redis.del(`session:${id}`);
  }
}

app.use(session({
  secret: process.env.SESSION_SECRET,
  store: new RedisStore(redisClient)
}));
```

#### ðŸ“¤ Multipart

Handles `multipart/form-data` file uploads.

```typescript
import { multipart } from "azurajs/plugins";

app.post('/upload', multipart({
  limits: { 
    fileSize: 10 * 1024 * 1024,
    files: 5
  },
  allowedTypes: ['image/jpeg', 'image/png', 'application/pdf'],
  uploadDir: './uploads'
}), (req, res) => {
  const files = req.files;
  const fields = req.fields;
  
  res.json({ 
    uploaded: files.length,
    files: files.map(f => ({
      name: f.originalFilename,
      size: f.size,
      type: f.mimetype
    })),
    fields 
  });
});
```

**Options:**
- `limits`: Size and count constraints.
- `allowedTypes`: Permitted MIME types.
- `uploadDir`: Destination directory.
- `keepExtensions`: Preserve file extensions.

#### ðŸ“ Body Limit

Restricts request body size.

```typescript
import { bodyLimit } from "azurajs/plugins";

app.use(bodyLimit({
  limit: '10mb',
  onLimit: (req, res) => {
    res.status(413).json({ 
      error: 'Payload too large',
      maxSize: '10mb'
    });
  }
}));
```

### Infrastructure Plugins

#### âš¡ Rate Limiting

Mitigates API abuse by limiting request rates.

```typescript
import { rateLimit } from "azurajs/plugins";

app.use('/api', rateLimit({
  windowMs: 60000,
  max: 100,
  message: 'Too many requests, please try again later',
  statusCode: 429,
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  keyGenerator: (req) => req.ip
}));
```

**Features:**
- Configurable windows.
- IP or custom key tracking.
- Custom error responses.

#### ðŸ”„ Proxy

Reverse proxy for microservices and API gateways.

```typescript
import { proxyPlugin } from "azurajs/plugins";

app.use('/api/users', proxyPlugin('http://users-service:4001', {
  pathRewrite: {
    '^/api/users': '/users'
  },
  headers: {
    'X-Custom-Header': 'AzuraJS-Proxy'
  },
  timeout: 5000,
  logLevel: 'info',
  onProxyReq: (proxyReq, req) => {
    proxyReq.setHeader('X-Real-IP', req.ip);
  },
  onProxyRes: (proxyRes, req, res) => {
    console.log(`Proxied: ${req.url} -> ${proxyRes.statusCode}`);
  }
}));
```

#### âš¡ Circuit Breaker

Implements fault tolerance patterns.

```typescript
import { circuitBreaker, CircuitBreaker } from "azurajs/plugins";

// Middleware Usage
app.use('/api/external', circuitBreaker({
  failureThreshold: 5,
  timeout: 60000,
  onOpen: () => {
    console.log('Circuit opened - stopping requests');
  },
  onClose: () => {
    console.log('Circuit closed - resuming requests');
  }
}));

// Utility Class Usage
const dbBreaker = new CircuitBreaker({
  failureThreshold: 3,
  timeout: 30000
});

app.get('/users', async (req, res) => {
  try {
    const users = await dbBreaker.execute(async () => {
      return await db.query('SELECT * FROM users');
    });
    res.json(users);
  } catch (error) {
    if (error.message === 'Circuit breaker is open') {
      return res.status(503).json({ 
        error: 'Service temporarily unavailable' 
      });
    }
    throw error;
  }
});
```

**States:**
- **Closed**: Normal operation.
- **Open**: Failures exceeded threshold; requests blocked.
- **Half-Open**: Probationary period testing service recovery.

### Real-time & Monitoring

#### ðŸ“Š Server-Sent Events (SSE)

Enables real-time server push capabilities.

```typescript
import { SSEManager, createSSEHandler } from "azurajs/plugins";

const sse = new SSEManager();

// Endpoint
app.get('/events', createSSEHandler(sse));

// Broadcast
app.post('/notify', (req, res) => {
  sse.broadcast({
    event: 'notification',
    data: { message: 'Hello everyone!' }
  });
  res.json({ sent: true });
});

// Targeted Message
app.post('/notify/:clientId', (req, res) => {
  sse.send(req.params.clientId, {
    event: 'private-message',
    data: { message: 'Just for you' }
  });
  res.json({ sent: true });
});

// Periodic Updates
setInterval(() => {
  sse.broadcast({
    event: 'metrics',
    data: {
      cpu: process.cpuUsage(),
      memory: process.memoryUsage(),
      uptime: process.uptime()
    }
  });
}, 1000);
```

**Client-side usage:**

```javascript
const eventSource = new EventSource('/events');

eventSource.addEventListener('notification', (event) => {
  const data = JSON.parse(event.data);
  console.log('Notification:', data.message);
});

eventSource.addEventListener('metrics', (event) => {
  const data = JSON.parse(event.data);
  updateDashboard(data);
});
```

#### ðŸ©º Health Check

Monitors application and dependency health.

```typescript
import { healthCheck } from "azurajs/plugins";

app.use('/health', healthCheck({
  checks: {
    database: async () => {
      try {
        await db.ping();
        return { 
          status: 'healthy',
          latency: 5,
          connections: db.pool.totalCount
        };
      } catch (error) {
        return { 
          status: 'unhealthy',
          error: error.message 
        };
      }
    },
    redis: async () => {
      try {
        await redis.ping();
        return { status: 'healthy' };
      } catch (error) {
        return { status: 'unhealthy', error: error.message };
      }
    },
    externalApi: async () => {
      const start = Date.now();
      try {
        await fetch('https://api.example.com/health');
        return { 
          status: 'healthy',
          responseTime: Date.now() - start
        };
      } catch (error) {
        return { status: 'unhealthy' };
      }
    }
  },
  timeout: 5000,
  cache: 10000
}));
```

**Response format:**

```json
{
  "status": "healthy",
  "timestamp": "2026-02-04T10:30:00.000Z",
  "uptime": 3600.5,
  "checks": {
    "database": {
      "status": "healthy",
      "latency": 5,
      "connections": 10
    },
    "redis": {
      "status": "healthy"
    },
    "externalApi": {
      "status": "healthy",
      "responseTime": 150
    }
  }
}
```

#### ðŸ”¢ Request ID

Assigns unique identifiers to requests for tracing.

```typescript
import { requestId } from "azurajs/plugins";

app.use(requestId({
  header: 'X-Request-ID',
  generator: () => crypto.randomUUID()
}));

app.use((req, res, next) => {
  console.log(`[${req.id}] ${req.method} ${req.url}`);
  res.set('X-Request-ID', req.id);
  next();
});
```

#### â±ï¸ Timeout

Prevents hanging requests.

```typescript
import { timeout } from "azurajs/plugins";

app.use(timeout({
  duration: 30000,
  onTimeout: (req, res) => {
    console.error(`Request timeout: ${req.method} ${req.url}`);
    res.status(408).json({ 
      error: 'Request timeout',
      message: 'The server did not receive a complete request in time'
    });
  }
}));
```

## Plugin Composition

Combining plugins enables robust application architectures.

### Production-Ready Setup

```typescript
import { AzuraClient } from "azurajs";
import { 
  helmet, 
  cors, 
  compression, 
  rateLimit, 
  requestId,
  timeout,
  bodyLimit,
  healthCheck
} from "azurajs/plugins";

const app = new AzuraClient();

// Security
app.use(helmet());
app.use(cors({ 
  origins: [process.env.FRONTEND_URL],
  credentials: true 
}));
app.use(bodyLimit({ limit: '10mb' }));

// Performance
app.use(compression({ threshold: 1024 }));
app.use(timeout({ duration: 30000 }));

// Monitoring
app.use(requestId());
app.use('/health', healthCheck({
  checks: {
    db: async () => ({ status: await db.isHealthy() ? 'healthy' : 'unhealthy' })
  }
}));

// Rate limiting
app.use('/api', rateLimit({
  windowMs: 60000,
  max: 100
}));

app.get('/api/users', (req, res) => {
  res.json({ users: [] });
});

app.listen(3000);
```

### Authentication API

```typescript
import { 
  helmet, 
  cors, 
  csrf,
  jwtMiddleware,
  createJWT,
  rateLimit,
  bodyLimit
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(cors({ origins: [process.env.FRONTEND_URL], credentials: true }));
app.use(bodyLimit({ limit: '1mb' }));

app.use('/auth', rateLimit({
  windowMs: 900000,
  max: 5
}));

app.post('/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  const user = await validateCredentials(email, password);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  const token = createJWT(
    { userId: user.id, role: user.role },
    { 
      secret: process.env.JWT_SECRET,
      expiresIn: 3600
    }
  );
  
  res.json({ token, user: { id: user.id, email: user.email } });
});

app.use('/api', jwtMiddleware({
  secret: process.env.JWT_SECRET,
  credentialsRequired: true
}));

app.get('/api/profile', (req, res) => {
  res.json({ user: req.user });
});
```

### File Upload Service

```typescript
import { 
  helmet,
  csrf,
  multipart,
  bodyLimit,
  jwtMiddleware
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(bodyLimit({ limit: '50mb' }));
app.use(csrf());

app.post('/upload',
  jwtMiddleware({ secret: process.env.JWT_SECRET }),
  multipart({
    limits: { 
      fileSize: 50 * 1024 * 1024,
      files: 10
    },
    allowedTypes: ['image/*', 'application/pdf', 'video/mp4']
  }),
  async (req, res) => {
    const files = req.files;
    const savedFiles = await Promise.all(
      files.map(file => saveToStorage(file))
    );
    
    res.json({ 
      uploaded: savedFiles.length,
      files: savedFiles 
    });
  }
);
```

### Microservices Gateway

```typescript
import { 
  helmet,
  cors,
  rateLimit,
  proxyPlugin,
  circuitBreaker,
  requestId,
  healthCheck
} from "azurajs/plugins";

const gateway = new AzuraClient();

gateway.use(helmet());
gateway.use(cors({ origins: ['*'] }));
gateway.use(requestId());
gateway.use(rateLimit({ max: 1000, windowMs: 60000 }));

gateway.use('/health', healthCheck({
  checks: {
    usersService: async () => {
      try {
        await fetch('http://users-service:4001/health');
        return { status: 'healthy' };
      } catch {
        return { status: 'unhealthy' };
      }
    },
    ordersService: async () => {
      try {
        await fetch('http://orders-service:4002/health');
        return { status: 'healthy' };
      } catch {
        return { status: 'unhealthy' };
      }
    }
  }
}));

gateway.use('/users', 
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin('http://users-service:4001', {
    pathRewrite: { '^/users': '' }
  })
);

gateway.use('/orders',
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin('http://orders-service:4002', {
    pathRewrite: { '^/orders': '' }
  })
);

gateway.listen(3000);
```

## Creating Custom Plugins

Create bespoke plugins by following the standard middleware pattern:

```typescript
import type { RequestHandler } from "azurajs";

interface CustomPluginOptions {
  enabled?: boolean;
  prefix?: string;
}

export function customPlugin(options: CustomPluginOptions = {}): RequestHandler {
  const { enabled = true, prefix = 'custom' } = options;
  
  return (req, res, next) => {
    if (!enabled) {
      return next();
    }
    
    req.customData = `${prefix}-${Date.now()}`;
    
    res.on('finish', () => {
      console.log(`Request finished: ${req.customData}`);
    });
    
    next();
  };
}
```

**Advanced Async Plugin:**

```typescript
export function asyncPlugin(options: Options): RequestHandler {
  return async (req, res, next) => {
    try {
      const data = await fetchSomeData();
      req.pluginData = data;
      next();
    } catch (error) {
      next(error);
    }
  };
}
```

## Best Practices

### 1. Order Matters

Layer plugins correctly for optimal functionality.

```typescript
// âœ… Correct order
app.use(helmet());            // 1. Security
app.use(cors());              // 2. CORS
app.use(bodyLimit());         // 3. Size Limits
app.use(compression());       // 4. Compression
app.use(requestId());         // 5. Tracing
app.use('/api', rateLimit()); // 6. Rate Limiting
```

### 2. Environment-Specific Configuration

Adapt settings based on the deployment environment.

```typescript
const isProduction = process.env.NODE_ENV === 'production';

app.use(helmet({
  hsts: isProduction ? { maxAge: 31536000 } : false
}));

app.use(session({
  cookie: {
    secure: isProduction,
    sameSite: isProduction ? 'strict' : 'lax'
  }
}));
```

### 3. Performance Tuning

Tune plugins for efficiency.

```typescript
app.use(compression({ 
  threshold: 2048
}));

app.use('/health', healthCheck({
  checks: { /* ... */ },
  cache: 30000
}));

app.use(rateLimit({
  windowMs: 1000,
  max: 10,
}));
```

### 4. Error Handling

Implement robust error management strategies.

```typescript
import { circuitBreaker } from "azurajs/plugins";

app.use('/api/external', circuitBreaker({
  failureThreshold: 5,
  timeout: 60000,
  onOpen: () => {
    monitoringService.alert('Circuit breaker opened');
  }
}));

app.use((error, req, res, next) => {
  console.error(`[${req.id}] Error:`, error);
  res.status(500).json({ 
    error: 'Internal server error',
    requestId: req.id 
  });
});
```

### 5. Security Checklist

Ensure the following for production deployments:

- âœ… Helmet for security headers
- âœ… CORS configured strictly
- âœ… Rate limiting on public endpoints
- âœ… Body size limits enforced
- âœ… CSRF protection for mutations
- âœ… Secure Authentication (JWT/Session)
- âœ… Request timeouts
- âœ… Health check monitoring

## Performance Impact

### Benchmark Results

- **Compression**: 60-70% bandwidth reduction
- **ETag**: 90% reduction for cached resources
- **Request ID**: &lt; 0.5ms overhead
- **JWT Middleware**: &lt; 2ms overhead
- **Rate Limit**: &lt; 1ms overhead

### Memory Usage

- **Session Store**: ~50 bytes per session
- **SSE Manager**: ~1KB per client
- **Rate Limit**: ~100 bytes per IP
- **Circuit Breaker**: ~100 bytes per instance
