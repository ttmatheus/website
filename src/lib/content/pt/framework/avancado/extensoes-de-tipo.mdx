---
title: ExtensÃµes de Tipo
description: Estenda os tipos de requisiÃ§Ã£o e resposta do AzuraJS
category: AvanÃ§ado
icon: lucide:type
order: 2
---

# ExtensÃµes de Tipo ğŸ§¬

O AzuraJS Ã© construÃ­do com TypeScript e oferece uma maneira flexÃ­vel de estender os tipos de requisiÃ§Ã£o (`RequestServer`) e resposta (`ResponseServer`) para incluir propriedades personalizadas. Isso Ã© extremamente Ãºtil quando vocÃª adiciona dados ao objeto de requisiÃ§Ã£o atravÃ©s de middlewares (por exemplo, informaÃ§Ãµes de usuÃ¡rio autenticado) ou quando precisa de mÃ©todos de resposta especÃ­ficos.

## Estendendo `RequestServer`

Para adicionar propriedades ao objeto `req`, vocÃª pode usar a tÃ©cnica de *declaration merging* do TypeScript. Crie um arquivo de declaraÃ§Ã£o de tipos (ex: `src/types/express.d.ts` ou `src/types/azura.d.ts`) e declare um mÃ³dulo para `azurajs/types`.

```typescript
// src/types/azura.d.ts

declare module "azurajs/types" {
  interface RequestServer {
    user?: {
      id: string;
      email: string;
      roles: string[];
    };
    tenantId?: string;
  }
}
```

Agora, em qualquer lugar da sua aplicaÃ§Ã£o, o objeto `req` terÃ¡ essas novas propriedades disponÃ­veis e tipadas:

```typescript
import { Controller, Get, Req } from "azurajs/decorators";
import type { RequestServer } from "azurajs/types";

@Controller("/profile")
export class ProfileController {
  @Get()
  getProfile(@Req() req: RequestServer) {
    // req.user agora Ã© reconhecido pelo TypeScript
    if (!req.user) {
      throw new Error("UsuÃ¡rio nÃ£o autenticado");
    }
    return { user: req.user };
  }
}
```

## Estendendo `ResponseServer`

Da mesma forma, vocÃª pode estender o objeto `res` para adicionar mÃ©todos ou propriedades personalizadas. Isso Ã© menos comum, mas pode ser Ãºtil para utilitÃ¡rios de resposta especÃ­ficos da sua aplicaÃ§Ã£o.

```typescript
// src/types/azura.d.ts

declare module "azurajs/types" {
  interface ResponseServer {
    sendSuccess(data: any, message?: string): void;
    sendError(statusCode: number, error: string, details?: any): void;
  }
}
```

E entÃ£o, vocÃª pode implementar esses mÃ©todos em um middleware ou usar a API nativa para simular:

```typescript
// Exemplo de middleware para adicionar mÃ©todos de resposta
import type { RequestServer, ResponseServer } from "azurajs/types";

export const customResponseMiddleware = (req: RequestServer, res: ResponseServer, next: () => Promise<void>) => {
  res.sendSuccess = (data, message = "Sucesso") => {
    res.status(200).json({ success: true, message, data });
  };
  res.sendError = (statusCode, error, details = null) => {
    res.status(statusCode).json({ success: false, error, details });
  };
  next();
};

// Uso no controller
@Controller("/data")
export class DataController {
  @Get()
  getData(@Res() res: ResponseServer) {
    res.sendSuccess({ items: [] }, "Dados carregados");
  }
}
```

## PrÃ³ximos Passos ğŸ“–

- [ğŸ”Œ **Middleware**](/docs/pt/conceitos/middleware): Entenda como middlewares podem popular as propriedades estendidas da requisiÃ§Ã£o.
- [ğŸš¨ **Tratamento de Erros**](/docs/pt/recursos/error-handling): Veja como usar `HttpError` para respostas de erro consistentes.
