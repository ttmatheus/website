---
title: Plugins
description: Guia completo de plugins do AzuraJS - estenda sua aplicaÃ§Ã£o com recursos poderosos integrados
category: Recursos
icon: lucide:plug
order: 10
---

# Plugins ğŸ”Œ

O AzuraJS inclui um ecossistema abrangente de **17 plugins integrados**, fornecendo funcionalidade robusta sem dependÃªncias externas. Esses plugins sÃ£o acessÃ­veis atravÃ©s da exportaÃ§Ã£o `azurajs/plugins` e aderem a uma API consistente e intuitiva.

## VisÃ£o Geral

Plugins no AzuraJS sÃ£o funÃ§Ãµes middleware aplicÃ¡veis globalmente ou a rotas especÃ­ficas. Eles sÃ£o projetados para ser:

- **Zero DependÃªncias**: ConstruÃ­dos inteiramente com mÃ³dulos nativos do Node.js.
- **Type-Safe**: Suporte completo a TypeScript com definiÃ§Ãµes detalhadas.
- **ComponÃ­veis**: Facilmente combinÃ¡veis para funcionalidades complexas.
- **PerformÃ¡ticos**: Otimizados para ambientes de produÃ§Ã£o.
- **ExtensÃ­veis**: CriaÃ§Ã£o de plugins personalizados simples.

## Plugins DisponÃ­veis

### Plugins de SeguranÃ§a

#### ğŸ›¡ï¸ Helmet

Implementa headers de seguranÃ§a para proteger contra vulnerabilidades comuns.

```typescript
import { AzuraClient } from "azurajs";
import { helmet } from "azurajs/plugins";

const app = new AzuraClient();

app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
    frameguard: { action: "deny" },
    noSniff: true,
    xssFilter: true,
    hidePoweredBy: true,
  }),
);
```

**OpÃ§Ãµes:**

- `contentSecurityPolicy`: vÃ¡rias diretivas CSP.
- `hsts`: ConfiguraÃ§Ãµes de HTTP Strict Transport Security.
- `frameguard`: ConfiguraÃ§Ã£o de X-Frame-Options.
- `noSniff`: Habilita X-Content-Type-Options: nosniff.
- `xssFilter`: Habilita X-XSS-Protection.
- `hidePoweredBy`: Remove o header X-Powered-By.
- `dnsPrefetchControl`: Controla o prefetching de DNS.
- `referrerPolicy`: Define a Referrer-Policy.

#### ğŸŒ CORS

Habilita Cross-Origin Resource Sharing.

```typescript
import { cors } from "azurajs/plugins";

app.use(
  cors({
    origins: ["http://localhost:3000", "https://example.com"],
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
    allowedHeaders: ["Content-Type", "Authorization"],
    exposedHeaders: ["X-Total-Count"],
    credentials: true,
    maxAge: 3600,
  }),
);
```

**OpÃ§Ãµes:**

- `origins`: Array de origens permitidas (`["*"]` para todas).
- `methods`: MÃ©todos HTTP permitidos.
- `allowedHeaders`: Headers de requisiÃ§Ã£o permitidos.
- `exposedHeaders`: Headers expostos ao navegador.
- `credentials`: Suporta cookies e headers de autorizaÃ§Ã£o.
- `maxAge`: DuraÃ§Ã£o do cache de preflight em segundos.

#### ğŸ”’ CSRF

Protege contra ataques de Cross-Site Request Forgery.

```typescript
import { csrf } from "azurajs/plugins";

app.use(
  csrf({
    secret: process.env.CSRF_SECRET,
    cookie: {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
    },
    ignoreMethods: ["GET", "HEAD", "OPTIONS"],
  }),
);

// Uso em rotas
app.get("/form", (req, res) => {
  res.send(`
    <form method="POST" action="/submit">
      <input type="hidden" name="_csrf" value="${req.csrfToken()}">
      <button>Enviar</button>
    </form>
  `);
});
```

**Funcionalidades:**

- GeraÃ§Ã£o automÃ¡tica de token.
- Armazenamento baseado em cookie ou sessÃ£o.
- MÃ©todos ignorados configurÃ¡veis.
- ValidaÃ§Ã£o de token.

#### ğŸ” AutenticaÃ§Ã£o JWT

Um sistema JWT completo incluindo assinatura, verificaÃ§Ã£o e middleware.

```typescript
import { jwtMiddleware, createJWT, verifyJWT } from "azurajs/plugins";

// CriaÃ§Ã£o de Token
const token = createJWT(
  { userId: 123, role: "admin" },
  {
    secret: process.env.JWT_SECRET,
    expiresIn: 3600,
    algorithm: "HS256",
    issuer: "meuapp",
    audience: "meuapp-usuarios",
  },
);

// ProteÃ§Ã£o de Rota
app.use(
  "/api/protected",
  jwtMiddleware({
    secret: process.env.JWT_SECRET,
    credentialsRequired: true,
    algorithm: "HS256",
    getToken: (req) => {
      const auth = req.headers.authorization;
      if (auth && auth.startsWith("Bearer ")) {
        return auth.substring(7);
      }
      return null;
    },
  }),
);

// Acessando Payload
app.get("/api/protected/profile", (req, res) => {
  const user = req.user;
  res.json({ user });
});

// VerificaÃ§Ã£o Manual
try {
  const payload = verifyJWT(token, {
    secret: process.env.JWT_SECRET,
  });
  console.log(payload);
} catch (error) {
  console.error("Token invÃ¡lido:", error.message);
}
```

**Funcionalidades:**

- Suporta algoritmos HS256, HS384 e HS512.
- Claims JWT padrÃ£o (exp, iat, nbf, iss, aud).
- ExtraÃ§Ã£o de token customizada.
- Acesso ao payload com seguranÃ§a de tipos.

### Plugins de Performance

#### ğŸ—œï¸ Compression

Comprime respostas automaticamente usando gzip, deflate ou Brotli.

```typescript
import { compression } from "azurajs/plugins";

app.use(
  compression({
    threshold: 1024,
    level: 6,
    filter: (contentType) => {
      return /json|text|javascript|css|xml|svg/.test(contentType);
    },
  }),
);
```

**OpÃ§Ãµes:**

- `threshold`: Tamanho mÃ­nimo da resposta em bytes.
- `level`: NÃ­vel de compressÃ£o (0-9).
- `filter`: FunÃ§Ã£o de filtro de tipo de conteÃºdo.

**BenefÃ­cios:**

- ReduÃ§Ã£o de largura de banda de atÃ© 70%.
- NegociaÃ§Ã£o automÃ¡tica de codificaÃ§Ã£o.
- Filtragem inteligente de tipo de conteÃºdo.

#### ğŸ·ï¸ ETag

Habilita cache HTTP via geraÃ§Ã£o e validaÃ§Ã£o de ETag.

```typescript
import { etag } from "azurajs/plugins";

app.use(
  etag({
    algorithm: "sha1",
    weak: true,
  }),
);
```

**Funcionalidades:**

- GeraÃ§Ã£o automÃ¡tica.
- Retorna 304 Not Modified quando apropriado.
- Suporta ETags fortes e fracas.

#### ğŸ—‚ï¸ Static Files

Serve arquivos estÃ¡ticos com cache e headers de seguranÃ§a.

```typescript
import { serveStatic } from "azurajs/plugins";

app.use(
  "/public",
  serveStatic("./public", {
    maxAge: 86400000,
    index: "index.html",
    dotfiles: "ignore",
    etag: true,
    lastModified: true,
    extensions: ["html", "htm"],
  }),
);
```

**OpÃ§Ãµes:**

- `maxAge`: DuraÃ§Ã£o do cache em ms.
- `index`: Arquivo de Ã­ndice padrÃ£o.
- `dotfiles`: EstratÃ©gia de manipulaÃ§Ã£o ('allow', 'ignore', 'deny').
- `etag`: Toggle de geraÃ§Ã£o de ETag.
- `lastModified`: Toggle de header Last-Modified.
- `extensions`: ExtensÃµes de arquivo para tentar.

### Plugins de ManipulaÃ§Ã£o de Dados

#### ğŸ“¦ Session

Gerencia sessÃµes de usuÃ¡rio via memÃ³ria ou stores customizadas.

```typescript
import { session } from "azurajs/plugins";

app.use(
  session({
    secret: process.env.SESSION_SECRET,
    name: "sessionId",
    cookie: {
      maxAge: 86400000,
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
    },
    rolling: true,
    resave: false,
    saveUninitialized: false,
  }),
);

app.post("/login", (req, res) => {
  req.session.userId = user.id;
  req.session.role = user.role;
  res.json({ success: true });
});

app.get("/profile", (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: "NÃ£o autorizado" });
  }
  res.json({
    userId: req.session.userId,
    role: req.session.role,
  });
});

app.post("/logout", (req, res) => {
  req.session.destroy();
  res.json({ success: true });
});
```

**Exemplo de Store Customizada:**

```typescript
class RedisStore {
  constructor(private redis: RedisClient) {}

  async get(id: string) {
    const data = await this.redis.get(`session:${id}`);
    return data ? JSON.parse(data) : null;
  }

  async set(id: string, data: any) {
    await this.redis.setex(`session:${id}`, 86400, JSON.stringify(data));
  }

  async destroy(id: string) {
    await this.redis.del(`session:${id}`);
  }
}

app.use(
  session({
    secret: process.env.SESSION_SECRET,
    store: new RedisStore(redisClient),
  }),
);
```

#### ğŸ“¤ Multipart

Manipula uploads de arquivos `multipart/form-data`.

```typescript
import { multipart } from "azurajs/plugins";

app.post(
  "/upload",
  multipart({
    limits: {
      fileSize: 10 * 1024 * 1024,
      files: 5,
    },
    allowedTypes: ["image/jpeg", "image/png", "application/pdf"],
    uploadDir: "./uploads",
  }),
  (req, res) => {
    const files = req.files;
    const fields = req.fields;

    res.json({
      uploaded: files.length,
      files: files.map((f) => ({
        name: f.originalFilename,
        size: f.size,
        type: f.mimetype,
      })),
      fields,
    });
  },
);
```

**OpÃ§Ãµes:**

- `limits`: RestriÃ§Ãµes de tamanho e quantidade.
- `allowedTypes`: Tipos MIME permitidos.
- `uploadDir`: DiretÃ³rio de destino.
- `keepExtensions`: Preservar extensÃµes de arquivo.

#### ğŸ“ Body Limit

Restringe o tamanho do corpo da requisiÃ§Ã£o.

```typescript
import { bodyLimit } from "azurajs/plugins";

app.use(
  bodyLimit({
    limit: "10mb",
    onLimit: (req, res) => {
      res.status(413).json({
        error: "Payload muito grande",
        maxSize: "10mb",
      });
    },
  }),
);
```

### Plugins de Infraestrutura

#### âš¡ Rate Limiting

Mitiga abuso da API limitando taxas de requisiÃ§Ã£o.

```typescript
import { rateLimit } from "azurajs/plugins";

app.use(
  "/api",
  rateLimit({
    windowMs: 60000,
    max: 100,
    message: "Muitas requisiÃ§Ãµes, tente novamente mais tarde",
    statusCode: 429,
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
    keyGenerator: (req) => req.ip,
  }),
);
```

**Funcionalidades:**

- Janelas configurÃ¡veis.
- Rastreamento por IP ou chave customizada.
- Respostas de erro customizadas.

#### ğŸ”„ Proxy

Proxy reverso para microsserviÃ§os e gateways de API.

```typescript
import { proxyPlugin } from "azurajs/plugins";

app.use(
  "/api/users",
  proxyPlugin("http://users-service:4001", {
    pathRewrite: {
      "^/api/users": "/users",
    },
    headers: {
      "X-Custom-Header": "AzuraJS-Proxy",
    },
    timeout: 5000,
    logLevel: "info",
    onProxyReq: (proxyReq, req) => {
      proxyReq.setHeader("X-Real-IP", req.ip);
    },
    onProxyRes: (proxyRes, req, res) => {
      console.log(`Proxied: ${req.url} -> ${proxyRes.statusCode}`);
    },
  }),
);
```

#### âš¡ Circuit Breaker

Implementa padrÃµes de tolerÃ¢ncia a falhas.

```typescript
import { circuitBreaker, CircuitBreaker } from "azurajs/plugins";

// Uso Middleware
app.use(
  "/api/external",
  circuitBreaker({
    failureThreshold: 5,
    timeout: 60000,
    onOpen: () => {
      console.log("Circuito aberto - parando requisiÃ§Ãµes");
    },
    onClose: () => {
      console.log("Circuito fechado - retomando requisiÃ§Ãµes");
    },
  }),
);

// Uso Classe UtilitÃ¡ria
const dbBreaker = new CircuitBreaker({
  failureThreshold: 3,
  timeout: 30000,
});

app.get("/users", async (req, res) => {
  try {
    const users = await dbBreaker.execute(async () => {
      return await db.query("SELECT * FROM users");
    });
    res.json(users);
  } catch (error) {
    if (error.message === "Circuit breaker is open") {
      return res.status(503).json({
        error: "ServiÃ§o temporariamente indisponÃ­vel",
      });
    }
    throw error;
  }
});
```

**Estados:**

- **Fechado**: OperaÃ§Ã£o normal.
- **Aberto**: Falhas excederam o limite; requisiÃ§Ãµes bloqueadas.
- **Meio-Aberto**: PerÃ­odo de experiÃªncia testando recuperaÃ§Ã£o do serviÃ§o.

### Tempo Real & Monitoramento

#### ğŸ“Š Server-Sent Events (SSE)

Habilita capacidades de push em tempo real no servidor.

```typescript
import { SSEManager, createSSEHandler } from "azurajs/plugins";

const sse = new SSEManager();

// Endpoint
app.get("/events", createSSEHandler(sse));

// Broadcast
app.post("/notify", (req, res) => {
  sse.broadcast({
    event: "notification",
    data: { message: "OlÃ¡ a todos!" },
  });
  res.json({ sent: true });
});

// Mensagem Direcionada
app.post("/notify/:clientId", (req, res) => {
  sse.send(req.params.clientId, {
    event: "private-message",
    data: { message: "Apenas para vocÃª" },
  });
  res.json({ sent: true });
});

// AtualizaÃ§Ãµes PeriÃ³dicas
setInterval(() => {
  sse.broadcast({
    event: "metrics",
    data: {
      cpu: process.cpuUsage(),
      memory: process.memoryUsage(),
      uptime: process.uptime(),
    },
  });
}, 1000);
```

**Uso no Client-side:**

```javascript
const eventSource = new EventSource("/events");

eventSource.addEventListener("notification", (event) => {
  const data = JSON.parse(event.data);
  console.log("NotificaÃ§Ã£o:", data.message);
});

eventSource.addEventListener("metrics", (event) => {
  const data = JSON.parse(event.data);
  updateDashboard(data);
});
```

#### ğŸ©º Health Check

Monitora a saÃºde da aplicaÃ§Ã£o e dependÃªncias.

```typescript
import { healthCheck } from "azurajs/plugins";

app.use(
  "/health",
  healthCheck({
    checks: {
      database: async () => {
        try {
          await db.ping();
          return {
            status: "healthy",
            latency: 5,
            connections: db.pool.totalCount,
          };
        } catch (error) {
          return {
            status: "unhealthy",
            error: error.message,
          };
        }
      },
      redis: async () => {
        try {
          await redis.ping();
          return { status: "healthy" };
        } catch (error) {
          return { status: "unhealthy", error: error.message };
        }
      },
      externalApi: async () => {
        const start = Date.now();
        try {
          await fetch("https://api.example.com/health");
          return {
            status: "healthy",
            responseTime: Date.now() - start,
          };
        } catch (error) {
          return { status: "unhealthy" };
        }
      },
    },
    timeout: 5000,
    cache: 10000,
  }),
);
```

**Formato de resposta:**

```json
{
  "status": "healthy",
  "timestamp": "2026-02-04T10:30:00.000Z",
  "uptime": 3600.5,
  "checks": {
    "database": {
      "status": "healthy",
      "latency": 5,
      "connections": 10
    },
    "redis": {
      "status": "healthy"
    },
    "externalApi": {
      "status": "healthy",
      "responseTime": 150
    }
  }
}
```

#### ğŸ”¢ Request ID

Atribui identificadores Ãºnicos Ã s requisiÃ§Ãµes para rastreamento.

```typescript
import { requestId } from "azurajs/plugins";

app.use(
  requestId({
    header: "X-Request-ID",
    generator: () => crypto.randomUUID(),
  }),
);

app.use((req, res, next) => {
  console.log(`[${req.id}] ${req.method} ${req.url}`);
  res.set("X-Request-ID", req.id);
  next();
});
```

#### â±ï¸ Timeout

Previne requisiÃ§Ãµes travadas.

```typescript
import { timeout } from "azurajs/plugins";

app.use(
  timeout({
    duration: 30000,
    onTimeout: (req, res) => {
      console.error(`Timeout na requisiÃ§Ã£o: ${req.method} ${req.url}`);
      res.status(408).json({
        error: "Timeout na requisiÃ§Ã£o",
        message: "O servidor nÃ£o recebeu uma requisiÃ§Ã£o completa a tempo",
      });
    },
  }),
);
```

## ComposiÃ§Ã£o de Plugins

Combinar plugins habilita arquiteturas de aplicaÃ§Ã£o robustas.

### Setup Pronto para ProduÃ§Ã£o

```typescript
import { AzuraClient } from "azurajs";
import {
  helmet,
  cors,
  compression,
  rateLimit,
  requestId,
  timeout,
  bodyLimit,
  healthCheck,
} from "azurajs/plugins";

const app = new AzuraClient();

// SeguranÃ§a
app.use(helmet());
app.use(
  cors({
    origins: [process.env.FRONTEND_URL],
    credentials: true,
  }),
);
app.use(bodyLimit({ limit: "10mb" }));

// Performance
app.use(compression({ threshold: 1024 }));
app.use(timeout({ duration: 30000 }));

// Monitoramento
app.use(requestId());
app.use(
  "/health",
  healthCheck({
    checks: {
      db: async () => ({
        status: (await db.isHealthy()) ? "healthy" : "unhealthy",
      }),
    },
  }),
);

// Rate limiting
app.use(
  "/api",
  rateLimit({
    windowMs: 60000,
    max: 100,
  }),
);

app.get("/api/users", (req, res) => {
  res.json({ users: [] });
});

app.listen(3000);
```

### API de AutenticaÃ§Ã£o

```typescript
import {
  helmet,
  cors,
  csrf,
  jwtMiddleware,
  createJWT,
  rateLimit,
  bodyLimit,
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(cors({ origins: [process.env.FRONTEND_URL], credentials: true }));
app.use(bodyLimit({ limit: "1mb" }));

app.use(
  "/auth",
  rateLimit({
    windowMs: 900000,
    max: 5,
  }),
);

app.post("/auth/login", async (req, res) => {
  const { email, password } = req.body;

  const user = await validateCredentials(email, password);
  if (!user) {
    return res.status(401).json({ error: "Credenciais invÃ¡lidas" });
  }

  const token = createJWT(
    { userId: user.id, role: user.role },
    {
      secret: process.env.JWT_SECRET,
      expiresIn: 3600,
    },
  );

  res.json({ token, user: { id: user.id, email: user.email } });
});

app.use(
  "/api",
  jwtMiddleware({
    secret: process.env.JWT_SECRET,
    credentialsRequired: true,
  }),
);

app.get("/api/profile", (req, res) => {
  res.json({ user: req.user });
});
```

### ServiÃ§o de Upload de Arquivos

```typescript
import {
  helmet,
  csrf,
  multipart,
  bodyLimit,
  jwtMiddleware,
} from "azurajs/plugins";

const app = new AzuraClient();

app.use(helmet());
app.use(bodyLimit({ limit: "50mb" }));
app.use(csrf());

app.post(
  "/upload",
  jwtMiddleware({ secret: process.env.JWT_SECRET }),
  multipart({
    limits: {
      fileSize: 50 * 1024 * 1024,
      files: 10,
    },
    allowedTypes: ["image/*", "application/pdf", "video/mp4"],
  }),
  async (req, res) => {
    const files = req.files;
    const savedFiles = await Promise.all(
      files.map((file) => saveToStorage(file)),
    );

    res.json({
      uploaded: savedFiles.length,
      files: savedFiles,
    });
  },
);
```

### Gateway de MicrosserviÃ§os

```typescript
import {
  helmet,
  cors,
  rateLimit,
  proxyPlugin,
  circuitBreaker,
  requestId,
  healthCheck,
} from "azurajs/plugins";

const gateway = new AzuraClient();

gateway.use(helmet());
gateway.use(cors({ origins: ["*"] }));
gateway.use(requestId());
gateway.use(rateLimit({ max: 1000, windowMs: 60000 }));

gateway.use(
  "/health",
  healthCheck({
    checks: {
      usersService: async () => {
        try {
          await fetch("http://users-service:4001/health");
          return { status: "healthy" };
        } catch {
          return { status: "unhealthy" };
        }
      },
      ordersService: async () => {
        try {
          await fetch("http://orders-service:4002/health");
          return { status: "healthy" };
        } catch {
          return { status: "unhealthy" };
        }
      },
    },
  }),
);

gateway.use(
  "/users",
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin("http://users-service:4001", {
    pathRewrite: { "^/users": "" },
  }),
);

gateway.use(
  "/orders",
  circuitBreaker({ failureThreshold: 5, timeout: 60000 }),
  proxyPlugin("http://orders-service:4002", {
    pathRewrite: { "^/orders": "" },
  }),
);

gateway.listen(3000);
```

## Criando Plugins Customizados

Crie plugins sob medida seguindo o padrÃ£o middleware padrÃ£o:

```typescript
import type { RequestHandler } from "azurajs";

interface CustomPluginOptions {
  enabled?: boolean;
  prefix?: string;
}

export function customPlugin(
  options: CustomPluginOptions = {},
): RequestHandler {
  const { enabled = true, prefix = "custom" } = options;

  return (req, res, next) => {
    if (!enabled) {
      return next();
    }

    req.customData = `${prefix}-${Date.now()}`;

    res.on("finish", () => {
      console.log(`RequisiÃ§Ã£o finalizada: ${req.customData}`);
    });

    next();
  };
}
```

**Plugin AssÃ­ncrono AvanÃ§ado:**

```typescript
export function asyncPlugin(options: Options): RequestHandler {
  return async (req, res, next) => {
    try {
      const data = await fetchSomeData();
      req.pluginData = data;
      next();
    } catch (error) {
      next(error);
    }
  };
}
```

## Melhores PrÃ¡ticas

### 1. A Ordem Importa

Posicione plugins em camadas corretamente para funcionalidade ideal.

```typescript
// âœ… Ordem correta
app.use(helmet()); // 1. SeguranÃ§a
app.use(cors()); // 2. CORS
app.use(bodyLimit()); // 3. Limites de Tamanho
app.use(compression()); // 4. CompressÃ£o
app.use(requestId()); // 5. Rastreamento
app.use("/api", rateLimit()); // 6. Rate Limiting
```

### 2. ConfiguraÃ§Ã£o EspecÃ­fica do Ambiente

Adapte configuraÃ§Ãµes baseadas no ambiente de deploy.

```typescript
const isProduction = process.env.NODE_ENV === "production";

app.use(
  helmet({
    hsts: isProduction ? { maxAge: 31536000 } : false,
  }),
);

app.use(
  session({
    cookie: {
      secure: isProduction,
      sameSite: isProduction ? "strict" : "lax",
    },
  }),
);
```

### 3. Ajuste de Performance

Ajuste plugins para eficiÃªncia.

```typescript
app.use(
  compression({
    threshold: 2048,
  }),
);

app.use(
  "/health",
  healthCheck({
    checks: {
      /* ... */
    },
    cache: 30000,
  }),
);

app.use(
  rateLimit({
    windowMs: 1000,
    max: 10,
  }),
);
```

### 4. Tratamento de Erros

Implemente estratÃ©gias de gerenciamento de erros robustas.

```typescript
import { circuitBreaker } from "azurajs/plugins";

app.use(
  "/api/external",
  circuitBreaker({
    failureThreshold: 5,
    timeout: 60000,
    onOpen: () => {
      monitoringService.alert("Circuit breaker aberto");
    },
  }),
);

app.use((error, req, res, next) => {
  console.error(`[${req.id}] Erro:`, error);
  res.status(500).json({
    error: "Erro interno do servidor",
    requestId: req.id,
  });
});
```

### 5. Checklist de SeguranÃ§a

Garanta o seguinte para deploys de produÃ§Ã£o:

- âœ… Helmet para headers de seguranÃ§a
- âœ… CORS configurado estritamente
- âœ… Rate limiting em endpoints pÃºblicos
- âœ… Limites de tamanho de body impostos
- âœ… ProteÃ§Ã£o CSRF para mutaÃ§Ãµes
- âœ… AutenticaÃ§Ã£o Segura (JWT/SessÃ£o)
- âœ… Timeouts de requisiÃ§Ã£o
- âœ… Monitoramento de health check

## Impacto na Performance

### Resultados de Benchmark

- **CompressÃ£o**: 60-70% de reduÃ§Ã£o de largura de banda
- **ETag**: 90% de reduÃ§Ã£o para recursos em cache
- **Request ID**: &lt; 0.5ms overhead
- **Middleware JWT**: &lt; 2ms overhead
- **Rate Limit**: &lt; 1ms overhead

### Uso de MemÃ³ria

- **Session Store**: ~50 bytes por sessÃ£o
- **SSE Manager**: ~1KB por cliente
- **Rate Limit**: ~100 bytes por IP
- **Circuit Breaker**: ~100 bytes por instÃ¢ncia
