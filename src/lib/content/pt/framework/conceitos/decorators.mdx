---
title: Decorators
description: Domine os decorators do AzuraJS para um c√≥digo limpo e expressivo
category: Conceitos Principais
icon: lucide:tag
order: 3
---

# Decorators üè∑Ô∏è

Decorators s√£o uma funcionalidade poderosa do TypeScript que permite adicionar metadados e l√≥gica a classes, m√©todos, propriedades e par√¢metros. No AzuraJS, eles formam a base para definir rotas, injetar depend√™ncias e configurar o comportamento da API de forma declarativa.

## Habilitando Decorators

Para utilizar decorators, atualize seu `tsconfig.json` com as seguintes op√ß√µes de compilador:

```json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

## Tipos de Decorators

### 1. Decorators de Classe

Aplicados a classes para definir seu papel (ex: como um Controller) e aplicar configura√ß√µes globais.

- `@Controller(prefix?: string)`: Marca uma classe como um controller. Aceita opcionalmente um prefixo de rota.

```typescript
import { Controller } from "azurajs/decorators";

@Controller("/api/v1")
export class MyController {}
```

### 2. Decorators de M√©todo

Estes decorators mapeiam m√©todos da classe para verbos HTTP e caminhos de rota espec√≠ficos.

- `@Get(path?: string)`
- `@Post(path?: string)`
- `@Put(path?: string)`
- `@Delete(path?: string)`
- `@Patch(path?: string)`
- `@Head(path?: string)`
- `@Options(path?: string)`

No exemplo abaixo, `getUser` mapeia para `GET /users/:id` e `createUser` mapeia para `POST /users`:

```typescript
import { Controller, Get, Post } from "azurajs/decorators";

@Controller("/users")
export class UserController {
  @Get("/:id")
  getUser() {
    /* ... */
  }

  @Post()
  createUser() {
    /* ... */
  }
}
```

### 3. Decorators de Par√¢metro

Utilize estes decorators para injetar dados da requisi√ß√£o diretamente nos argumentos dos seus m√©todos, evitando a an√°lise manual.

- `@Req()`: Objeto de requisi√ß√£o
- `@Res()`: Objeto de resposta
- `@Next()`: Fun√ß√£o Next (middleware)
- `@Param(name?: string)`: Par√¢metros de rota
- `@Query(name?: string)`: Par√¢metros de query
- `@Body(name?: string)`: Corpo da requisi√ß√£o
- `@Headers(name?: string)`: Cabe√ßalhos da requisi√ß√£o
- `@Cookies(name?: string)`: Cookies da requisi√ß√£o
- `@Ip()`: IP do cliente

```typescript
import { Controller, Get, Param, Query, Body, Post } from "azurajs/decorators";

@Controller("/products")
export class ProductController {
  @Get("/:id")
  getProduct(
    @Param("id") productId: string,
    @Query("version") version?: string,
  ) {
    return { productId, version };
  }

  @Post()
  createProduct(@Body() productData: any) {
    return { created: productData };
  }
}
```

## Registro na Aplica√ß√£o

Os decorators s√≥ s√£o processados quando registrados. Voc√™ deve chamar `applyDecorators()` no seu arquivo de entrada.

```typescript
import { AzuraClient } from "azurajs";
import { applyDecorators } from "azurajs/decorators";
import { UserController } from "./controllers/UserController";

const app = new AzuraClient();
applyDecorators(app, [UserController]);
```

## Pr√≥ximos Passos üìñ

- [üîå **Middleware**](/docs/pt/framework/conceitos/middleware): Entenda como os middlewares funcionam com o roteamento.
- [üéØ **Controllers**](/docs/pt/framework/conceitos/controllers): Veja como os decorators s√£o aplicados na pr√°tica.
